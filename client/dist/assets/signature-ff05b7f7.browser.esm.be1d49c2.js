import{a8 as ae,bi as ne,bj as $,aG as re,bd as W,bk as h,bl as q,b4 as x,bm as R,bn as _,_ as se,al as ie,B as C,bb as D,aq as b,aL as G,ba as oe,bo as ce,az as v,b5 as p,bc as J,bp as le,aM as L,bq as ue,aH as Q,br as de,bs as B,bt as me,bu as N,bv as pe,bw as j,bx as ye}from"./index.0708ba85.js";import{M as O}from"./index.c05fda0a.js";import{S as Y,E as he}from"./assertEnabled-bf987093.browser.esm.b8916aaa.js";import{N as E}from"./setErc20Allowance-f181219a.browser.esm.a541b727.js";function Ue(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerTransaction:e.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims||0}}function We(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerWallet:e.maxClaimablePerWallet,metadata:e.metadata||""}}function P(e,t){return e==="unlimited"?x:R(e,t)}async function Z(e){const a=Array.from({length:Math.ceil(e.length/25e3)},(s,o)=>e.slice(o*25e3,o*25e3+25e3)),r=[],n=await Promise.all(a.map(s=>j.parseAsync(s)));for(const s of n)r.push(...s);return r}const fe=2;let U=function(e){return e[e.V1=1]="V1",e[e.V2=2]="V2",e}({});class f{constructor(t,a,r,n,s){this.storage=t,this.shardNybbles=n,this.baseUri=a,this.originalEntriesUri=r,this.tokenDecimals=s,this.shards={},this.trees={}}static async fromUri(t,a){try{const r=await a.downloadJSON(t);if(r.isShardedMerkleTree)return f.fromShardedMerkleTreeInfo(r,a)}catch{return}}static async fromShardedMerkleTreeInfo(t,a){return new f(a,t.baseUri,t.originalEntriesUri,t.shardNybbles,t.tokenDecimals)}static hashEntry(t,a,r,n){switch(n){case U.V1:return Q(["address","uint256"],[t.address,P(t.maxClaimable,a)]);case U.V2:return Q(["address","uint256","uint256","address"],[t.address,P(t.maxClaimable,a),P(t.price||"unlimited",r),t.currencyAddress||b])}}static async fetchAndCacheDecimals(t,a,r){if(!r)return 18;let n=t[r];return n===void 0&&(n=(await de(a,r)).decimals,t[r]=n),n}static async buildAndUpload(t,a,r,n,s){let o=arguments.length>5&&arguments[5]!==void 0?arguments[5]:fe;const i=await Z(t),c={};for(const T of i){const g=T.address.slice(2,2+o).toLowerCase();c[g]===void 0&&(c[g]=[]),c[g].push(T)}const u={},d=await Promise.all(Object.entries(c).map(async T=>{let[g,M]=T;return[g,new O(await Promise.all(M.map(async A=>{const te=await f.fetchAndCacheDecimals(u,r,A.currencyAddress);return f.hashEntry(A,a,te,s)})),B,{sort:!0}).getHexRoot()]})),l=Object.fromEntries(d),y=new O(Object.values(l),B,{sort:!0}),S=[];for(const[T,g]of Object.entries(c)){const M={proofs:y.getProof(l[T]).map(A=>"0x"+A.data.toString("hex")),entries:g};S.push({data:JSON.stringify(M),name:`${T}.json`})}const w=await n.uploadBatch(S),k=w[0].slice(0,w[0].lastIndexOf("/")),m=await n.upload(i),V={merkleRoot:y.getHexRoot(),baseUri:k,originalEntriesUri:m,shardNybbles:o,tokenDecimals:a,isShardedMerkleTree:!0},ee=await n.upload(V);return{shardedMerkleInfo:V,uri:ee}}async getProof(t,a,r){const n=t.slice(2,2+this.shardNybbles).toLowerCase();let s=this.shards[n];const o={};if(s===void 0)try{const l=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;s=this.shards[n]=await this.storage.downloadJSON(`${l}${n}.json`);const y=await Promise.all(s.entries.map(async S=>{const w=await f.fetchAndCacheDecimals(o,a,S.currencyAddress);return f.hashEntry(S,this.tokenDecimals,w,r)}));this.trees[n]=new O(y,B,{sort:!0})}catch{return null}const i=s.entries.find(l=>l.address.toLowerCase()===t.toLowerCase());if(!i)return null;const c=await f.fetchAndCacheDecimals(o,a,i.currencyAddress),u=f.hashEntry(i,this.tokenDecimals,c,r),d=this.trees[n].getProof(u).map(l=>"0x"+l.data.toString("hex"));return me.parseAsync({...i,proof:d.concat(s.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(t){return console.warn("Could not fetch original snapshot entries",t),[]}}}async function Se(e,t,a,r,n,s){if(!a)return null;const o=a[t];if(o){const i=await n.downloadJSON(o);if(i.isShardedMerkleTree&&i.merkleRoot===t)return await(await f.fromShardedMerkleTreeInfo(i,n)).getProof(e,r,s);const c=await _.parseAsync(i);if(t===c.merkleRoot)return c.claims.find(u=>u.address.toLowerCase()===e.toLowerCase())||null}return null}function qe(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims}}function De(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:e.metadata}}async function we(e,t,a,r,n){const s=e.getSigner(),o=e.getProvider(),i=(await se(()=>import("./index.0708ba85.js").then(S=>S.fr),["assets/index.0708ba85.js","assets/index.63cb93ae.css"])).default,c=new ie(s||o,t,i,e.options,e.storage),u=await e.getSignerAddress(),d=e.address,l=await c.read("allowance",[u,d]),y=C.from(a).mul(C.from(r)).div(R("1",n));l.lt(y)&&await c.sendTransaction("approve",[d,l.add(y)])}async function Le(e,t,a,r,n,s,o,i,c){let u=P(a.maxClaimablePerWallet,n),d=[D([0],32)],l=a.price,y=a.currencyAddress;try{if(!a.merkleRootHash.toString().startsWith(b)){const m=await Se(e,a.merkleRootHash.toString(),await r(),s.getProvider(),o,c);if(m)d=m.proof,u=m.maxClaimable==="unlimited"?x:R(m.maxClaimable,n),l=m.price===void 0||m.price==="unlimited"?x:await G(s.getProvider(),m.price,m.currencyAddress||b),y=m.currencyAddress||b;else if(c===U.V1)throw new Error("No claim found for this address")}}catch(m){if((m==null?void 0:m.message)==="No claim found for this address")throw m;console.warn("failed to check claim condition merkle root hash, continuing anyways",m)}const S=await s.getCallOverrides()||{},w=l.toString()!==x.toString()?l:a.price,k=y!==b?y:a.currencyAddress;return w.gt(0)&&(oe(k)?S.value=C.from(w).mul(t).div(R("1",n)):i&&await we(s,k,w,t,n)),{overrides:S,proofs:d,maxClaimable:u,price:w,currencyAddress:k,priceInProof:l,currencyAddressInProof:y}}const be=(()=>p.object({name:p.string(),symbol:p.string(),decimals:p.number()}))(),Ce=(()=>be.extend({value:h,displayValue:p.string()}))(),Te=(()=>p.object({name:p.string().optional()}).catchall(p.unknown()))(),H=(()=>p.object({startTime:Y,currencyAddress:p.string().default(L),price:W.default(0),maxClaimableSupply:N,maxClaimablePerWallet:N,waitInSeconds:q.default(0),merkleRootHash:pe.default(D([0],32)),snapshot:p.optional(j).nullable(),metadata:Te.optional()}))(),ge=(()=>p.array(H))(),K=(()=>H.extend({availableSupply:N,currentMintSupply:N,currencyMetadata:Ce.default({value:C.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:h,waitInSeconds:h,startTime:h.transform(e=>new Date(e.toNumber()*1e3)),snapshot:j.optional().nullable()}))();async function Pe(e,t,a,r,n){const s=await Z(e),o=s.map(u=>u.address);if(new Set(o).size<o.length)throw new ye;const c=await f.buildAndUpload(s,t,a,r,n);return{merkleRoot:c.shardedMerkleInfo.merkleRoot,snapshotUri:c.uri}}function ke(e,t){const a=C.from(e),r=C.from(t);return a.eq(r)?0:a.gt(r)?1:-1}async function xe(e,t,a,r,n){const s=[];return{inputsWithSnapshots:await Promise.all(e.map(async i=>{if(i.snapshot&&i.snapshot.length>0){const c=await Pe(i.snapshot,t,a,r,n);s.push(c),i.merkleRootHash=c.merkleRoot}else i.merkleRootHash=D([0],32);return i})),snapshotInfos:s}}async function Ae(e,t,a,r){const n=e.currencyAddress===b?L:e.currencyAddress,s=P(e.maxClaimableSupply,t),o=P(e.maxClaimablePerWallet,t);let i;return e.metadata&&(typeof e.metadata=="string"?i=e.metadata:i=await r.upload(e.metadata)),{startTimestamp:e.startTime,maxClaimableSupply:s,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await G(a,e.price,n),currency:n,merkleRoot:e.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:e.waitInSeconds||0,metadata:i}}async function je(e,t,a,r,n){const{inputsWithSnapshots:s,snapshotInfos:o}=await xe(e,t,a,r,n),i=await ge.parseAsync(s),c=(await Promise.all(i.map(u=>Ae(u,t,a,r)))).sort((u,d)=>ke(u.startTimestamp,d.startTimestamp));return{snapshotInfos:o,sortedConditions:c}}async function Ie(e,t,a){if(!t)return null;const r=t[e];if(r){const n=await a.downloadJSON(r);if(n.isShardedMerkleTree&&n.merkleRoot===e){const s=await f.fromUri(r,a);return(s==null?void 0:s.getAllEntries())||null}else{const s=await _.parseAsync(n);if(e===s.merkleRoot)return s.claims.map(o=>({address:o.address,maxClaimable:o.maxClaimable,price:o.price,currencyAddress:o.currencyAddress}))}}return null}function I(e,t){return e.toString()===x.toString()?"unlimited":v(e,t)}async function He(e,t,a,r,n,s){var y;const o=await ce(a,e.currency,e.pricePerToken),i=I(e.maxClaimableSupply,t),c=I(e.maxClaimablePerWallet,t),u=I(C.from(e.maxClaimableSupply).sub(e.supplyClaimed),t),d=I(e.supplyClaimed,t);let l;return e.metadata&&(l=await n.downloadJSON(e.metadata)),K.parseAsync({startTime:e.startTimestamp,maxClaimableSupply:i,maxClaimablePerWallet:c,currentMintSupply:d,availableSupply:u,waitInSeconds:(y=e.waitTimeInSecondsBetweenClaims)==null?void 0:y.toString(),price:C.from(e.pricePerToken),currency:e.currency,currencyAddress:e.currency,currencyMetadata:o,merkleRootHash:e.merkleRoot,snapshot:s?await Ie(e.merkleRoot,r,n):void 0,metadata:l})}async function ze(e,t,a){if(e>=a.length)throw Error(`Index out of bounds - got index: ${e} with ${a.length} conditions`);const r=a[e].currencyMetadata.decimals,n=a[e].price,s=v(n,r),o=await H.parseAsync({...a[e],price:s,...t}),i=await K.parseAsync({...o,price:n});return a.map((c,u)=>{let d;u===e?d=i:d=c;const l=v(d.price,r);return{...d,price:l}})}let Ve=function(e){return e.NotEnoughSupply="There is not enough supply to claim.",e.AddressNotAllowed="This address is not on the allowlist.",e.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",e.ClaimPhaseNotStarted="Claim phase has not started yet.",e.AlreadyClaimed="You have already claimed the token.",e.WrongPriceOrCurrency="Incorrect price or currency.",e.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",e.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",e.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",e.NoClaimConditionSet="There is no claim condition set.",e.NoWallet="No wallet connected.",e.Unknown="No claim conditions found.",e}({});function Re(e){if(e===void 0){const t=ae.Buffer.alloc(16);return ne({},t),$(re(t.toString("hex")))}else return $(e)}const X=(()=>p.object({to:J.refine(e=>e.toLowerCase()!==b,{message:"Cannot create payload to mint to zero address"}),price:W.default(0),currencyAddress:le.default(L),mintStartTime:Y,mintEndTime:he,uid:p.string().optional().transform(e=>Re(e)),primarySaleRecipient:J.default(b)}))(),Ne=(()=>X.extend({quantity:W}))(),$e=(()=>Ne.extend({mintStartTime:h,mintEndTime:h}))(),z=(()=>X.extend({metadata:E,royaltyRecipient:p.string().default(b),royaltyBps:ue.default(0)}))(),F=(()=>z.extend({metadata:E.default(""),uri:p.string(),royaltyBps:h,mintStartTime:h,mintEndTime:h}))(),Ee=(()=>z.extend({metadata:E.default(""),quantity:q}))(),Je=(()=>Ee.extend({tokenId:q}))(),Qe=(()=>F.extend({tokenId:h,quantity:h}))(),_e=(()=>z.extend({metadata:E.default(""),quantity:h.default(1)}))(),Ge=(()=>F.extend({quantity:h.default(1)}))(),Ye=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ze=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ke=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Xe=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}];export{X as B,Ve as C,Ke as M,Je as S,we as a,Qe as b,P as c,Ue as d,We as e,Se as f,Le as g,U as h,_e as i,Ge as j,Ze as k,qe as l,Xe as m,De as n,Ne as o,je as p,$e as q,Ye as r,Re as s,He as t,ze as u};
